'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.animate = animate;
exports.changeDirection = changeDirection;

var _movement = require('./movement');

var _monster = require('./monster');

var _player = require('./player');

function collectEatenMonsterScores(newState, oldState) {
    var scoreDelta = newState.monsters.reduce(function (sum, _ref, index) {
        var deadTime = _ref.deadTime;
        return sum + 1000 * ((deadTime > 0 && oldState.monsters[index].deadTime === 0) >> 0);
    }, 0);

    return _extends({}, newState, { score: newState.score + scoreDelta });
}

function animate(state) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$time = _ref2.time,
        time = _ref2$time === undefined ? Date.now() : _ref2$time;

    // get the next game state as a function of time

    var timeSeconds = (time - state.stepTime) / 1000;

    if (state.lost) {
        return state;
    }

    var statePlayerAnimated = (0, _player.animatePlayer)(_extends({}, state, { stepTime: time }), timeSeconds);

    var stateMonstersAnimated = (0, _monster.animateMonsters)(statePlayerAnimated, timeSeconds, state.player);

    var stateEatenMonsters = collectEatenMonsterScores(stateMonstersAnimated, state);

    return stateEatenMonsters;
}

function changeDirection(state, _ref3) {
    var direction = _ref3.direction;

    var orderPolarityOld = (0, _movement.orderPolarity)(state.player.direction);
    var orderPolarityNew = (0, _movement.orderPolarity)(direction);

    if (orderPolarityOld.plane === orderPolarityNew.plane) {
        return _extends({}, state, {
            player: _extends({}, state.player, {
                direction: direction,
                nextDirection: direction
            })
        });
    }

    return _extends({}, state, {
        player: _extends({}, state.player, {
            nextDirection: direction
        })
    });
}
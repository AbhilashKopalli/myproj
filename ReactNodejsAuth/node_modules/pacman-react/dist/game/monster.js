'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.animateMonsters = animateMonsters;

var _constants = require('../constants');

var constants = _interopRequireWildcard(_constants);

var _tracks = require('./tracks');

var _tracks2 = _interopRequireDefault(_tracks);

var _movement = require('./movement');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function getAvailableVectors(_ref) {
    var newPosition = _ref.newPosition,
        plane = _ref.plane,
        trackTo = _ref.trackTo,
        distanceFromTrack = _ref.distanceFromTrack,
        movedDistance = _ref.movedDistance,
        availableOptions = _ref.availableOptions,
        player = _ref.player,
        eating = _ref.eating;

    return availableOptions.map(function (direction) {
        var _orderPolarity = (0, _movement.orderPolarity)(direction),
            optionPolarity = _orderPolarity.polarity,
            optionPlane = _orderPolarity.plane;

        var position = null;
        if (plane === optionPlane) {
            position = newPosition;
        } else {
            position = [];
            position[optionPlane] = newPosition[optionPlane] + Math.max(0, movedDistance - distanceFromTrack) * optionPolarity;

            position[1 - optionPlane] = trackTo;
        }

        var compare = [];
        compare[optionPlane] = newPosition[optionPlane] + optionPolarity;
        compare[1 - optionPlane] = position[1 - optionPlane];

        return { compare: compare, position: position, direction: direction };
    }).sort(function (_ref2, _ref3) {
        var posA = _ref2.compare;
        var posB = _ref3.compare;
        return Math.pow(-1, eating >> 0) * ((0, _movement.gridDistance)(posA, player.position) - (0, _movement.gridDistance)(posB, player.position));
    }).map(function (_ref4) {
        var direction = _ref4.direction,
            position = _ref4.position;
        return { direction: direction, position: position };
    });
}

function getNextMonsterHomePosition(newPosition, monster, player) {
    if (monster.direction === constants.EAST && monster.position[0] < constants.MONSTER_HOME_EXIT_COL && newPosition[0] >= constants.MONSTER_HOME_EXIT_COL || monster.direction === constants.WEST && monster.position[0] > constants.MONSTER_HOME_EXIT_COL && newPosition[0] <= constants.MONSTER_HOME_EXIT_COL) {

        return {
            position: [constants.MONSTER_HOME_EXIT_COL, newPosition[1]],
            direction: constants.NORTH
        };
    }
    if (monster.direction === constants.NORTH && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH] && newPosition[1] >= constants.MONSTER_HOME_RANGE[constants.NORTH]) {

        return {
            position: [newPosition[0], constants.MONSTER_HOME_RANGE[constants.NORTH]],
            direction: !monster.directionBias && monster.position[0] < player.position[0] ? constants.EAST : constants.WEST
        };
    }

    return { position: newPosition };
}

function getIsHome(monster) {
    return monster.position[0] > constants.MONSTER_HOME_RANGE[constants.WEST] && monster.position[0] < constants.MONSTER_HOME_RANGE[constants.EAST] && monster.position[1] > constants.MONSTER_HOME_RANGE[constants.SOUTH] && monster.position[1] < constants.MONSTER_HOME_RANGE[constants.NORTH];
}

function getAvailableMonsterRoutes(_ref5) {
    var newPosition = _ref5.newPosition,
        collision = _ref5.collision,
        plane = _ref5.plane,
        trackTo = _ref5.trackTo,
        monster = _ref5.monster;

    var availableOptions = [];
    var distanceFromTrack = 0;

    if (trackTo !== -1 && _tracks2.default[1 - plane][trackTo]) {
        var passedTrack = _tracks2.default[1 - plane][trackTo].find(function (_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2),
                start = _ref7[0],
                end = _ref7[1];

            return newPosition[1 - plane] >= start && newPosition[1 - plane] <= end;
        });

        var options = [null, null];
        if (passedTrack[0] < newPosition[1 - plane]) {
            options[0] = plane === 0 ? constants.SOUTH : constants.WEST;
        }
        if (passedTrack[1] > newPosition[1 - plane]) {
            options[1] = plane === 0 ? constants.NORTH : constants.EAST;
        }

        availableOptions = options.filter(function (item) {
            return item !== null;
        });

        distanceFromTrack = Math.abs(newPosition[plane] - trackTo);
    }

    if (!collision) {
        availableOptions.push(monster.direction);
    }

    return { availableOptions: availableOptions, distanceFromTrack: distanceFromTrack };
}

function getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player) {
    // determine where to move a monster if it has a decision to make
    var _orderPolarity2 = (0, _movement.orderPolarity)(monster.direction),
        order = _orderPolarity2.order,
        plane = _orderPolarity2.plane;

    var trackTo = (0, _movement.snapToTrack)(plane, order, newPosition, movedDistance);
    if (trackTo === -1 && collision) {
        throw new Error('Collided but nothing to track to');
    }

    var _getAvailableMonsterR = getAvailableMonsterRoutes({
        newPosition: newPosition, collision: collision, plane: plane, trackTo: trackTo, monster: monster
    }),
        availableOptions = _getAvailableMonsterR.availableOptions,
        distanceFromTrack = _getAvailableMonsterR.distanceFromTrack;

    if (!availableOptions.length) {
        // this happens when wrapping

        return { position: newPosition };
    }

    var vectors = getAvailableVectors({
        newPosition: newPosition,
        plane: plane,
        trackTo: trackTo,
        distanceFromTrack: distanceFromTrack,
        movedDistance: movedDistance,
        availableOptions: availableOptions,
        player: player,
        eating: monster.eatingTime > 0
    });

    var distanceFromPlayer = (0, _movement.gridDistance)(vectors[0].position, player.position);

    if (distanceFromPlayer < constants.PLAYER_RADIUS * 1.8) {
        if (monster.eatingTime) {
            // monster got eaten

            return { deadTime: constants.MONSTER_DEATH_TIME_SECONDS };
        }

        // player got eaten
        return { lost: true };
    }

    return vectors[0];
}

function getNewMonsterVector(monster, player, time) {
    if (monster.deadTime > time) {
        return _extends({}, monster, {
            deadTime: monster.deadTime - time
        });
    }
    if (monster.deadTime > 0) {
        return _extends({}, monster, {
            deadTime: 0,
            eatingTime: 0,
            position: monster.startingPosition,
            direction: monster.startingDirection
        });
    }

    var eatingTime = Math.max(0, monster.eatingTime - time);

    var isHome = getIsHome(monster);

    var speed = monster.eatingTime ? constants.MONSTER_SPEED_RETREAT : constants.MONSTER_SPEED_ATTACK;

    try {
        var _getNewPosition = (0, _movement.getNewPosition)(monster.position, monster.direction, speed, time, !isHome),
            newPosition = _getNewPosition.newPosition,
            collision = _getNewPosition.collision,
            movedDistance = _getNewPosition.movedDistance;

        if (isHome) {
            return getNextMonsterHomePosition(newPosition, monster, player);
        }

        return _extends({}, getNavigatedMonsterVector(newPosition, collision, movedDistance, monster, player), {
            eatingTime: eatingTime
        });
    } catch (err) {
        // wrapped or something

        return {};
    }
}

function animateMonster(state, time, player, monster, index) {
    var _getNewMonsterVector = getNewMonsterVector(monster, player, time),
        lost = _getNewMonsterVector.lost,
        monsterVector = _objectWithoutProperties(_getNewMonsterVector, ['lost']);

    var newMonsters = state.monsters.slice();

    newMonsters[index] = _extends({}, monster, monsterVector);

    if (lost) {
        return _extends({}, state, { lost: true });
    }

    return _extends({}, state, { monsters: newMonsters });
}

function animateMonsters(state, time, player) {
    return state.monsters.reduce(function (lastState, monster, index) {
        return animateMonster(lastState, time, player, monster, index);
    }, state);
}
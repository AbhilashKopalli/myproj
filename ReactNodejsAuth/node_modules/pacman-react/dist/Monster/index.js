'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _helpers = require('../helpers');

require('./style.scss');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function MonsterEye(_ref) {
    var radius = _ref.radius,
        offset = _ref.offset,
        direction = _ref.direction;

    var eyeballCenterX = radius * (1 + 0.4 * offset);
    var eyeballCenterY = radius * 0.7;
    var eyeballRadius = radius * 0.3;

    var reverse = Math.pow(-1, (direction < 2) >> 0);
    var vertical = direction % 2;
    var horizontal = 1 - vertical;

    var irisOffsetX = -horizontal * reverse;
    var irisOffsetY = vertical * reverse;

    var outerProps = {
        cx: eyeballCenterX,
        cy: eyeballCenterY,
        'r': eyeballRadius,
        fill: 'white'
    };

    var irisProps = {
        cx: eyeballCenterX + eyeballRadius / 2 * irisOffsetX,
        cy: eyeballCenterY + eyeballRadius / 2 * irisOffsetY,
        'r': eyeballRadius / 2,
        fill: 'black'
    };

    return _react2.default.createElement(
        'g',
        { className: 'eye' },
        _react2.default.createElement('circle', outerProps),
        _react2.default.createElement('circle', irisProps)
    );
}

MonsterEye.propTypes = {
    radius: _propTypes2.default.number.isRequired,
    offset: _propTypes2.default.number.isRequired,
    direction: _propTypes2.default.number.isRequired
};

function getMonsterPath(radius) {
    var width = radius * 2;
    var height = radius * 2;
    var radiusSmall = radius / 5;

    return ['M' + radius + ',0', 'A' + radius + ',' + radius + ' 0 0 1 ' + width + ',' + radius, 'L' + width + ',' + (height - radiusSmall), 'A' + radiusSmall + ',' + radiusSmall + ' 0 0 1 ' + (width - radiusSmall * 2) + ',' + (height - radiusSmall), 'A' + radiusSmall + ',' + radiusSmall + ' 0 0 0 ' + (width - radiusSmall * 4) + ',' + (height - radiusSmall), 'A' + radiusSmall + ',' + radiusSmall + ' 0 0 1 ' + (width - radiusSmall * 6) + ',' + (height - radiusSmall), 'A' + radiusSmall + ',' + radiusSmall + ' 0 0 0 ' + (width - radiusSmall * 8) + ',' + (height - radiusSmall), 'A' + radiusSmall + ',' + radiusSmall + ' 0 0 1 ' + (width - radiusSmall * 10) + ',' + (height - radiusSmall), 'L0,' + (height - radiusSmall), 'L0,' + radius, 'A' + radius + ',' + radius + ' 0 0 1 ' + radius + ',0'].join(' ');
}

function WaveMouth(_ref2) {
    var gridSize = _ref2.gridSize,
        eating = _ref2.eating;

    if (!eating) {
        return null;
    }

    var waveRadius = gridSize * 0.125;
    var yPos = gridSize * 0.95;

    var mouthPath = ['M' + waveRadius * 2 + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 1 ' + 3 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 0 ' + 4 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 1 ' + 5 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 0 ' + 6 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 1 ' + 7 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 0 ' + 8 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 1 ' + 9 * waveRadius + ',' + yPos, 'A' + waveRadius + ',' + waveRadius * 5 + ' 0 0 0 ' + 10 * waveRadius + ',' + yPos].join(' ');

    return _react2.default.createElement('path', { d: mouthPath, stroke: 'white', strokeWidth: 1 });
}

WaveMouth.propTypes = {
    gridSize: _propTypes2.default.number.isRequired,
    eating: _propTypes2.default.bool.isRequired
};

function getColor(eating, eatingFlash, color) {
    if (eating) {
        if (eatingFlash) {
            return '#c9a';
        }

        return '#06c';
    }

    return color;
}

function MonsterIcon(_ref3) {
    var gridSize = _ref3.gridSize,
        eating = _ref3.eating,
        eatingFlash = _ref3.eatingFlash,
        position = _ref3.position,
        direction = _ref3.direction,
        color = _ref3.color;

    var radius = gridSize * 0.75;
    var monsterPath = getMonsterPath(radius);
    var pathProps = {
        stroke: 'none',
        fill: getColor(eating, eatingFlash, color)
    };

    var style = _extends({}, (0, _helpers.cssPosition)(position, gridSize), {
        width: radius * 2,
        height: radius * 2,
        marginLeft: -radius,
        marginTop: -radius
    });

    return _react2.default.createElement(
        'svg',
        { className: 'pacman-monster', style: style },
        _react2.default.createElement('path', _extends({ d: monsterPath }, pathProps)),
        _react2.default.createElement(WaveMouth, { gridSize: gridSize, eating: eating }),
        _react2.default.createElement(MonsterEye, { radius: radius, direction: direction, offset: -1 }),
        _react2.default.createElement(MonsterEye, { radius: radius, direction: direction, offset: 1 })
    );
}

MonsterIcon.propTypes = {
    eating: _propTypes2.default.bool.isRequired,
    eatingFlash: _propTypes2.default.number,
    gridSize: _propTypes2.default.number.isRequired,
    position: _propTypes2.default.array.isRequired,
    color: _propTypes2.default.string.isRequired,
    direction: _propTypes2.default.number.isRequired
};

var Monster = function (_Component) {
    _inherits(Monster, _Component);

    function Monster(props) {
        _classCallCheck(this, Monster);

        var _this = _possibleConstructorReturn(this, (Monster.__proto__ || Object.getPrototypeOf(Monster)).call(this, props));

        _this.state = {
            eatingFlash: 0,
            timerFlash: _this.getTimerFlash()
        };
        return _this;
    }

    _createClass(Monster, [{
        key: 'getTimerFlash',
        value: function getTimerFlash() {
            var _this2 = this;

            if (this.state) {
                clearInterval(this.state.timerFlash);
            }

            if (!this.props.eatingTime) {
                return null;
            }

            return setInterval(function () {
                _this2.setState({ eatingFlash: (_this2.state.eatingFlash + 1) % 2 });
            }, 500);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (this.props.eatingTime > 0 && prevProps.eatingTime === 0 || this.props.eatingTime === 0 && prevProps.eatingTime > 0) {

                this.setState({ timerFlash: this.getTimerFlash() });
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearInterval(this.state.timerFlash);
        }
    }, {
        key: 'render',
        value: function render() {
            if (this.props.deadTime > 0) {
                return null;
            }

            var _props = this.props,
                eatingTime = _props.eatingTime,
                props = _objectWithoutProperties(_props, ['eatingTime']);

            var eating = eatingTime > 0;

            return _react2.default.createElement(MonsterIcon, _extends({ eating: eating }, props, this.state));
        }
    }]);

    return Monster;
}(_react.Component);

Monster.propTypes = {
    gridSize: _propTypes2.default.number.isRequired,
    position: _propTypes2.default.array.isRequired,
    direction: _propTypes2.default.number.isRequired,
    color: _propTypes2.default.string.isRequired,
    eatingTime: _propTypes2.default.number.isRequired,
    deadTime: _propTypes2.default.number.isRequired
};
exports.default = Monster;